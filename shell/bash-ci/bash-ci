#!/bin/bash

APPNAME="$( basename "$0")"
[[ -r "/etc/${APPNAME}.conf" ]] && . "/etc/${APPNAME}.conf"
[[ -r "$HOME/.${APPNAME}.conf" ]] && . "$HOME/.${APPNAME}.conf"

usage() {
  echo "Usage: $0 function" >&2
  echo "Functions: add_project" >&2
  echo "$@" >&2
  exit 1
}

CMD_PREFIX="${CMD_PREFIX:-bash}"
WWW_DIR="${WWW_DIR:-/var/www/${APPNAME}}"
PROJECTS_DIR="${PROJECTS_DIR:-/var/lib/${APPNAME}}"
EDITOR="${EDITOR:-vim}"

project_basedir() {
  echo "${PROJECTS_DIR}/${project_name}"
}

project_workdir() {
  echo "$( project_basedir )/work"
}

project_buildfile() {
  echo "$( project_basedir )/build.sh"
}

project_repodir() {
  echo "$( project_basedir )/repo"
}

projectfile() {
  echo "$( project_basedir)/bashci-project"
}


git_init_repo() {
  git clone "$1" "$(project_repodir)"
  ( cd "$(project_repodir)" && git submodule init )
}

git_update_repo_command() {
 echo '( cd ${REPO_DIR} && git pull && git submodule update )'
}


add_project() {
  project_name="$1"
  repo_type="$2"
  repo_url="$3"
  [ -z "$repo_url" ] && usage "add_project repo_name repo_type repo_url (repo type currently supported: git)"
  mkdir -p "$( project_workdir )"
  "${repo_type}_init_repo" "$repo_url"
  cat >"$( projectfile )" <<EOF
PROJECT_NAME="$project_name"
PROJECT_DESCRIPTION=""
PROJECT_DIR="$( project_workdir )"
REPO_DIR="$( project_repodir )"
EOF
  cat >"$( project_buildfile )" <<EOF
#!/bin/bash

. "$( projectfile )"

## $project_name build file. Tweak it and add build options to make it automatically run.
## Available environment variables: PROJECTS_DIR PROJECT_NAME PROJECT_DESCRIPTION REPO_DIR
## You can also parse arguments in "\$@" before starting any build, for instance to set a working branch.


# Update repository function: tweak if needed
bashci_build_00_update_repo() {
  $( "${repo_type}_update_repo_command" )
}

## Name your build functions with bashci_build_nn_name and the CI system will automatically run them in sequence
bashci_build_01_start_build() {
  false
}

## You can also define hooks for build success and failure:

bashci_success_trigger() {
  true
}

bashci_failure_trigger() {
  false
}

EOF
  $EDITOR "$( project_buildfile )"
}

build_project() {
  project_name="$1"; shift
  [ -r "$( project_buildfile )" ] && . "$( project_buildfile )" 
  touch "$( project_workdir)/building"
  declare -F| grep bashci_build_ | awk '{ print $3 }' | sort -n | while read fname; do
    echo "$( date -Is ) - Running '${fname#bashci_build_??_}'" >&2
    "$fname" || exit 1
  done
  status_code="$?"
  [[ "${status_code}" == 0 ]] && build_status="success" || build_status="failure"
  echo "$(date -Is) - Build finished: $build_status ($status_code)" >&2
  [[ "$( type -t "bashci_${build_status}_trigger" )" == "function" ]] && bashci_${build_status}_trigger
  rm -f "$( project_workdir)/building"
  echo "$status_code|$build_status" > "$( project_workdir)/last_build"
  exit "${status_code}"
}

trigger_build() {
  project_name="$1"
  build_id="$( date -Is )"

  logfile="$( project_workdir )/build-${build_id}.log"
  echo "Launched build with id $build_id, logfile: $logfile"
  rm -f "$( project_workdir )/build.log"; ln -s "$logfile" "$( project_workdir )/build.log"
  ( nohup "$0" build_project "$@" > "$logfile" 2>&1 & )2>/dev/null
}

if [[ -n "$1" && "$( type -t "$1" )" == "function" ]]; then "$@"; else usage; fi
